Ext.data.JsonP.v2_beyond_the_guide_edit_validation({"guide":"<h1>How Edit Validation Works</h1>\n<div class='toc'>\n<p><strong>Contents</strong></p>\n<ol>\n<li><a href='#!/guide/v2_beyond_the_guide_edit_validation-section-1'>Edit Validation Cycle</a></li>\n<li><a href='#!/guide/v2_beyond_the_guide_edit_validation-section-2'>Field Validation</a></li>\n<li><a href='#!/guide/v2_beyond_the_guide_edit_validation-section-3'>Validators</a></li>\n</ol>\n</div>\n\n<p>An important part of forms is the client-side validation, not as a means to prevent bad data from going into your database but a way to encourage the user to enter the data she is intending to.</p>\n\n<p>First we will examine the base Edit view and how it checks each field, prevents submitting and shows the error container. Then we will add a simple \"max length\" validator to prevent overly long AccountNames in the Account Edit View from the Create a Simple Edit View topic.</p>\n\n<h2 id='v2_beyond_the_guide_edit_validation-section-1'>Edit Validation Cycle</h2>\n\n<p>If you wish to follow along you may open <code>argos-sdk/src/Edit.js</code>, but most functions are self-explanitory.</p>\n\n<p>1. When a user enters data and presses the Save toolbar item the <code>save()</code> function is called and all existing errors are cleared out and hidden then it calls the Edit Views <code>validate()</code>.</p>\n\n<p>2. Inside <code>validate()</code> we see that it loops over <code>this.fields</code> which is a collection of each \"field object\" and then calls <code>field.validate()</code>.</p>\n\n<p>3. If the <code>field.validate()</code> returns a string (eg, not <code>false</code>) then it means there is an error, and the string is the error message. It adds the <code>row-error</code> class to the field object container and adds an object containing the error message and field name to the <code>this.errors</code> collection.</p>\n\n<p>4. After all fields are validated, the Edit Views <code>validate()</code> function returns true if there are any errors in <code>this.errors</code>.</p>\n\n<p>5. Back in <code>save()</code> if <code>validate()</code> returned true then it calls <code>showValidationSummary()</code> and stops the save process.</p>\n\n<p>6. <code>showValidationSummary()</code> adds each error by using the <code>validationSummaryItemTemplate</code> with the error item (with message text) and then just the field name. Which is then joined and added to the <code>validationContentNode</code> and the class <code>panel-form-error</code> is added to the Edit Views' container div.</p>\n\n<h2 id='v2_beyond_the_guide_edit_validation-section-2'>Field Validation</h2>\n\n<p>Every field widget derives from the base </em>Field which has the <a href=\"#!/api/Sage.Platform.Mobile.Fields._Field-method-validate\" rel=\"Sage.Platform.Mobile.Fields._Field-method-validate\" class=\"docClass\">validate()</a> logic. Without going into the nitty gritty details, it returns false if everything is okay or if no validators are defined.</p>\n\n<h2 id='v2_beyond_the_guide_edit_validation-section-3'>Validators</h2>\n\n<p>Validators are quick and simple methods for adding validation logic, they can be defined as: RegExp, functions, or objects that have either <code>test</code> for RegExp or <code>fn</code> for function. Objects may also have a <code>message</code> defined for custom error messages. If the message is define it is treated as a <code>string.substitute</code> format string and is passed: value, field name, field label as <code>${0}</code>, <code>${1}</code> and <code>${2}</code> respectively.</p>\n\n<p>This part assumes you've completed <a href=\"#!/guide/v2_template-guide\">Argos-Template Guide</a>.</p>\n\n<p>1. Open <code>argos-template/src/Views/Account/Edit</code> down to <code>createLayout()</code> and the AccountName field.</p>\n\n<p>2. Add a new property: <code>validator</code> and set it to an empty object:</p>\n\n<pre><code>            children: [{\n                name: 'AccountName',\n                property: 'AccountName',\n                label: this.accountNameText,\n                validator: {}\n            },{\n</code></pre>\n\n<p>3. First we will use the \"object with function and custom message\" approach. Add the key <code>fn</code> set to <code>this.exceedsLength</code> and <code>message</code> to <code>this.exceedsLengthErrorText</code>:</p>\n\n<pre><code>                validator: {\n                    fn: this.exceedsLength,\n                    message: this.exceedsLengthErrorText\n                }\n</code></pre>\n\n<p>4. Add the function <code>exceedsLength()</code>, all validator functions get passed the current value and the field. Have the function return true if the length of the value is over 255. Remember that true means \"this is an error\".</p>\n\n<pre><code>exceedsLength: function(value, field) {\n    return value &amp;&amp; value.length &gt; 255; \n},\n</code></pre>\n\n<p>5. Add the invalid message text:</p>\n\n<pre><code>exceedsLengthErrorText: \"The field '${2}' value exceeds the allowed limit in length.\",\n</code></pre>\n\n<p>6. Save and run your app and try creating a new Account where the name has more than 255 characters. You should see a red box with your error message.</p>\n\n<p>7. Now go back to the same file, same function, same field object and let's add another validator. The <code>validator</code> property also accepts arrays of validators and the field will fail to validate if any of the validators fail.</p>\n\n<p>8. For this new validator lets use the \"object with RegExp and message\" approach. Add a new validator with the <code>test</code> and message<code>keys with</code>this.notEmptyRE<code>and</code>this.notEmptyErrorText`:</p>\n\n<pre><code>    validator: [{\n           fn: this.exceedsLength,\n           message: this.exceedsLengthErrorText\n        },{\n           test: this.notEmptyRE,\n           message: this.notEmptyErrorText\n        }\n    ]\n</code></pre>\n\n<p>9. Define <code>noteEmptyRE</code> to test for any char, in the case of RegExp tests it is the reverse - if it matches then its a good value, if it doesn't match the RE it's a bad value:</p>\n\n<pre><code>notEmpty: /.+/,\n</code></pre>\n\n<p>10. And the not empty error message:</p>\n\n<pre><code>notEmptyErrorText: 'The field '${2}' cannot be empty.',\n</code></pre>\n\n<p>11. Save and run your app and try to insert an Account with no name. You should see the error message come up.</p>\n\n<p>Setting the validtor key on a field object enables validation to take place - the common approach to to pass an object with either <code>fn</code> or <code>test</code> for the matching logic and <code>message</code> for the custom message to show. Just remember that in your <code>fn</code> you also get passed the field object itself -- giving you access to possible custom parameters (min/max values, start/end dates, all set per field).</p>\n","title":"Edit Validation"});